# 对象特性

构造函数与析构函数
-------

构造函数 ： 类名（）{}
构造函数，没有返回值也不写void
函数名称与类名相同
构造函数可以有参数，因此可以发生重载
程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

析构函数 ： ～类名（）{}
析构函数，没有返回值也不写void
函数名称与类名相同，载名称前加上符号～
析构函数不可以有参数，因此不可以发生重载
程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

构造函数的分类及调用
-------

按参数分为：有参构造和无参构造（默认构造）
```
//普通构造函数
class Person 
{
public:
    Person(){}
    Person(int a){}
}
//拷贝构造函数
Person（const Person &p）{
    //将传入的人身上的所有属性，拷贝到我身上
    age=p.age
}//引用的方式传进来 并且不改变p
```
按类型分为：普通构造和拷贝构造


三种调用方式：
```
//1、括号法
Person p1;//默认构造函数调用
Person p2(10);//有参构造函数
Person p3(p2);//拷贝构造函数
//在调用默认构造函数时候，不要加（）
//因为下面这行代码，编译器会认为是一个函数的声明，不会认为在创建对象
Person p1();

//2、显示法
Person p1;
Person p2 = Person(10);//有参构造
Person p3= Person(p2);//拷贝构造
Person(10);//匿名对象 特点：当前行执行结束后，系统会立即回收匿名对象
//注意事项
//不要利用拷贝函数，初始化匿名对象,编译器会认为是p3对象的声明
Person(p3);

3、隐式转换法
Person p4 =10;//相当于写了 Person p4 =Person (10);  有参构造
Person p5=p4;//拷贝构造
```

3、拷贝构造函数调用时机
通常有三种情况
* 1、使用一个已经创建完毕的对象来初始化一个新对象
* 2、值传递的方式给函数参数传值

```
void doWork(Person p){
//p是p1的拷贝
}
void test02(){
    Person p1;
    doWork(p1);//
}
```
* 3、值方式返回局部对象

```
Person doWork2(){
    Person p1;
    return p1;//返回的是p1的拷贝
}
void test02(){
    Person p= doWork2();
}
```

1、只要创建一个类，c++编译器会给每个类都添加至少3个函数
//默认构造（空实现）
//析构函数（空实现）
//拷贝构造（值拷贝）
2、如果我们写了有参构造函数，编译器就不再提供默认构造，但是依旧提供拷贝构造
3、如果我们写了拷贝构造函数，编译器就不再提供默认构造，有参构造